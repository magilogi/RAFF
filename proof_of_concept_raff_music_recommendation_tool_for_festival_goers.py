# -*- coding: utf-8 -*-
"""Proof-of-Concept - RAFF: Music recommendation tool for Festival-goers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V39GKZwe0-GDVBu-maZBVasE24Xml2xE

**Welcome to the proof-of-concept demo for RAFF: A new Music Recommendation tool for festival-goers.**

---

! Run each cell sequentially, below. If any error occurs, try restarting the runtime.

Step 1: Loading dependencies
"""

!pip3 install spotipy --upgrade #Downloading Spotipy



import spotipy
import requests
import numpy as np
import pandas as pd
from spotipy import util
from collections import Counter

"""Step 2: Spotify API authorization. Since the tool is not implemented in a web application yet, the API token must be manually retrieved. For this private demonstration I have not redacted my private key. Please do not copy or share"""

# Input your Spotify credentials. For a more interactive experience use own credentials. This demo version features my credentials. 
username = "Nikolaj Munch"
scope = 'user-library-read user-top-read user-follow-read app-remote-control streaming'
client_id = "ca3dbbb16ddb49e2a7d74ba90885db04"
client_secret = "7b06f6ae0e2d43d3aefa8f52a17323de"
redict_uri = "http://example.com/callback/"


tk = spotipy.SpotifyOAuth(client_id=client_id, client_secret=client_secret, redirect_uri=redict_uri, scope=scope, open_browser=False)

sp = spotipy.Spotify(auth_manager = tk)

"""Step 3: Defining data aggregation and processing functions"""

def process_user_data():
  artists_longterm = pd.DataFrame(sp.current_user_top_artists(limit = 30, time_range = "long_term")['items']) # Get long term listening habits
  artists_mediumterm = pd.DataFrame(sp.current_user_top_artists(limit = 30, time_range = "medium_term")['items']) # Get medium term listening habits
  artists_shortterm = pd.DataFrame(sp.current_user_top_artists(limit = 30, time_range = "short_term")['items']) # Get long term listening habits
  artists_all = pd.concat([artists_longterm, artists_mediumterm, artists_shortterm])  # Combine time-frames for full profile of music taste
  return artists_all



def clean_user_data():
  artist_genres = artists_all.filter(items=['genres', 'name']) #Create a new dataframe with only artists' names and genres.
  artist_genres_s = artist_genres.drop_duplicates(subset='name', keep="first") #Remove duplicate artists that arises from concatenating the time ranges
  artist_genres_s = artist_genres_s[artist_genres_s['genres'].map(lambda d: len(d)) > 0] #Remove artists where genre information is unavailable
  artist_genres_s = artist_genres_s.reset_index(drop=True) #Reset index of dataframe
  artist_genres_s #Show final music taste dataframe
  return(artist_genres_s)

#For demonstration purposes half of the user data will be used to generate the user's listening analysis, and the other half of the data, will be treated as a hypothetical festival line-up
#When utilizing this tool for a real festival, the line-up data will contain of metadata obtained through GET-requests from all of the artists IDs in the line-up.

user = artist_genres_s[0:27] #Split data to emulate personal user data 
lineup = artist_genres_s[28:55] # and hypothetical festival lineup

#For this demo we are attending a small festival in California. 
#Knowing that I prefer hip-hop, rap and pop, it is to be expected that I'm suggested such artists. --> View the artists in the festival line-up below
print(lineup['name'].to_string(index=False))

def data_to_dict():
  Count_U = user['genres'].apply(Counter) #Turn genre metadata into Counter dictionary with frequency of genres
  user1 = user.assign(Count_U=Count_U.values) #Map to original artists
  taste_df = user1.genres.sum() #Summarize and remove low frequencies of personal preferred genres for most accuracy preference comparison
  taste_dict = Counter(taste_df) # ^
  taste_dict_s = {k:v for k,v in taste_dict.items() if v != 1} # ^
  return(taste_dict_s)

def lineup_to_dict():
  Count_L = lineup['genres'].apply(Counter) #Turn genre metadata for lineup into dict of genre frequency 
  lineup_d = lineup.assign(Count_L=Count_L.values) #Assign dict to original artists
  return(lineup_d)

def calculate_similarity_scores(): #This function will compare each key (genre) in the lineup_dict (genre overview of each artist) with the preferred genres of the user. and output which artists in the line-up overlap the most. 
  lineup_dicts = lineup_d['Count_L']
  total = []
  i = 0
  for band in lineup_dicts:
      i += 1
      band_count = 0 #resets with each band/artist
      for key in band:
            band_count += key in taste_dict_s
      i += band_count
      #print(f"Band: {band} Matches: {band_count}")
      #print(f"Overall count so far: {i}")
      total.append((band_count))
  lineup['Matches'] = total
  return(lineup)

def ranking_scores(): #This function sorts the artists with most overlap of preferred genres. And outputs top 10 artists with most overlaps
  lineup_s = lineup.sort_values(by=['Matches'], ascending=False)
  top10suggestions = lineup_s['name'][0:10]
  return(top10suggestions)

def output_recommendations():
  print(f"Thanks for trying out the Proof-of-concept version of RAFF. Based on your(/my) music taste you should go see :  {top10suggestions.to_string(index=False)} ---- Have fun at the festival!")

"""Step 4: Running demo"""

print("Getting user data... Copy redirected URL link and paste it")
artists_all = process_user_data()
print("Cleaning user data...")
artist_genres_s = clean_user_data()
print("Converting data to dictionaires")
taste_dict_s = data_to_dict()
lineup_d = lineup_to_dict()
print("Calculating similarity scores...")
lineup = calculate_similarity_scores()
print("")
top10suggestions = ranking_scores()
output_recommendations()

#If you are feeling adventurous and do not want to stay within your comfort zone, you can flip the suggestions giving you the least similar artists. 

def low_ranking_scores(): #This function sorts the artists with least overlap of preferred genres. And outputs top 10 artists with least overlaps
  lineup_s = lineup.sort_values(by=['Matches'], ascending=False)
  bottom10suggestions = lineup_s['name'].iloc[-10:]
  return(bottom10suggestions)

bottom10suggestions = low_ranking_scores()
print(f"If you want to listen to something you're not use to, go hear: {bottom10suggestions.to_string(index=False)}        --> Enjoy! :) ")